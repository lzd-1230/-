模块一:线性结构
	连续存储[数组] 
	离散存储[链表]
	应用:1.栈 2.队列
	专题:递归
		1.1+2+...+100 
	 	2.求阶乘
		3.汉诺塔
		4.走迷宫

模块二:非线性结构
	树
	图
	
模块三:查找和排序
	排序:
		冒泡
		选择
		快速
		归并
		
什么是数据结构:把现实中的问题以特定的数据类型保存在内存之中,再以特定操作实现某个功能(查找删除等)
	当要存储1w个人的姓名时,再用数组就无法完成了,连续的内存可能不够
	把数据分为1.个体如何保存  2.个体和个体的关系如何保存 
	对于不同的数据结构,算法是不同的(对存储数据的操作) 
	
算法的衡量标准
	1.时间复杂度:大概要执行的次数,而非执行时间
	2.空间复杂度:大概所占用的最大内存
	3.难易程度
	4.健壮性
	
预备知识: 
	指针
		指针就是地址,地址就是指针
		指针变量是存放地址的变量
		指针的本质是一个操作受限的非负整数
	指针与数组
		a[i]和*(a+i)是一样的
	指针与函数
		当传入一个数组的首地址进入函数后,对函数中该变量的操作即就是对原数组的操作
	不同数据类型的指针
		存放的都是第一个字节的地址 
		但每个数据类型所占的字节数目不同,因此需要告知类型.
		!因此无论指针变量指的数据有多大,它本身永远仅占4个字节 
	结构体
		为什么要有结构体?
			一个个体有多个信息需要储存
			自己定义的复合数据类型
		使用结构体的两种方式 
			1.直接定义结构体变量,通过st.成员
			2.结构体指针的方式struct student* st; st->成员
		 	12方法等价  
	动态内存的分配和释放 
 		为什么要动态?
		 	可以动态扩充
		初始化方法
			类型+变量名=(该类型)malloc 
			在链表中体现在,仅需要把动态创建一个链表的函数赋值给一个结构体指针,即可完成链表的创建
			
数据存储
	线性存储:把所有的节点用一根线穿起来
		包括连续存储[数组],离散(内存空间上的)存储[链表] 
	数组 
		什么是数组?
			类型相同,类型相等的一坨东西 
	自己定义数组
	struct Array{
		int* pBase;		//第一个元素的地址 
		int length;		//数组总长度 
		int cnt;		//当前有效元素的个数 
//		int increase; 	//自动增长因子(超出一次,所增加的内存大小) 
	};  

typedef struct student{
	char name[20];
	char sex;
}* PST;		//PST等价于*struct student * 

链表:
	定义:①不连续存储②通过指针相连③除了首尾,每一个节点前后有且只有一个节点. 
		专业术语:
			首节点VS头节点:头节点不存放有效数据,目的是为了方便操作 
			头指针VS尾指针:头指针指向头结点,尾指针指向尾节点
		确定一个链表需要几个参数?
			头指针足以,头节点数据量可能很大
			不同链表的头结点的大小可能不同 
		每一个节点的数据类型:
			typedef struct Node{
				DATA;				//数据域 
				struct Node* pNext;	//指针域 
			}NODE,*PNODE;	//NODE是struct Node,PNODE是struct Node* 
	分类:
		单链表、双链表(双指针域)
		循环链表(最后一个指针域又指回来了):能通过任何一个节点找到其它所有节点 
	算法(操作):
		遍历
		查找
		清空
		求长度
		排序
		插入节点
		
	删除一个节点:
		r=p->pNext;
		p->pNext=r->pNext;
		free(r);
		
	链表:
		创建链表的关键:建立一个可更新的尾节点,不断==pNew;
		遍历链表的关键:创建一个P从pHead开始,不断p=p->pNext迭代输出,直到p->pNext==NULL
		 
	优缺点:
		数组
			优点:存取速度快 
			缺点: 插入删除要移动其它元素,慢,事先要预测长度 
		链表
			优点:空间没有限制,插入删除快,存取容量可以理解成无线 
			缺点:存取速度慢 
复习
	数据存储问题只需搞定:个体如何存储?个体之间的关系如何存储?
	算法:狭义就是根据不同数据存储方式,有不同的手法

栈
	在c语言中的静态内存和动态内存里讲过
	静态内存(局部变量)是在栈中分配,动态内存(malloc)在堆中分配 
	栈和堆指的是分配方式的不同"先进后出"or"堆排序" 
	定义: 能实现"先进后出"的存储方式,类似箱子放书,吃了吐 
	
	栈的分类:静态栈和动态栈 
		
	算法:
		出栈
		压栈
	栈的应用:
		①函数调用
		②中断
		③计算器原理 
		④走迷宫算法
队列
	定义:一种可以实现"先进先出"的存储结构,类似排队买票,吃饭拉屎.
	分类:	链式队列			--链表实现 
			数组(静态)队列 		--数组实现
	思想:将数组进行限制,从而达到队列的效果通常用循环队列实现. 
	
	循环队列的讲解:
		1.静态队列为什么一定要是循环队列?
			因为非循环队列中无论是插入还是删除,f和r只能增,因此总会有空间的浪费
			而且当r和f指到队列末尾时希望再+1就回到队首. 
		2.循环队列要几个参数? 
			front和rear,两个参数不同场合有不同含义 
		3.循环队列各个参数的含义
			三种场合有不同含义:
				①初始化
					front和rear都为0这个位置 
				②非空
					front:队列的第一个元素下标 
					rear:最后一个的下一个的下标(待插入的下标) 
				③空 
					front和rear值相等
		4.循环队列出、入队伪算法讲解
			入队:
				①将值存入r所指的位置
				②r=r+1不普适,普适算法:r=(r+1)%数组长度
			出队: 
				①f=(f+1)%数组长度 
		5.是否为空
			front是否==rear则队列一定为空 
		6.是否满 
			法一:多增加一个标识参数 (想要n个元素都存放) 
				
			法二:少用一个元素
				当(r+1)%长度==f时即满
		注:	r和f的大小关系不明确!!因此不能以此来判度队列是否已满 
			当r和f相等的时候说不清是空还是满,固我们只用n-1个位置,相等时一定为空
			循环链表里面的+1翻译成:x=(x+1)%长度 
	队列:所有和时间相关的应用都有队列的影子.
	
递归:
	定义:一个函数自己直接或间接调用自己
	几个例子:
		1.1+2+3+4...+100
		2.求阶乘
		3.汉诺塔
		4.走迷宫		
	为什么函数可以自己调用自己?
		在一个函数调用另一个函数之前,系统需要完成三件事情:
			1.将实参的值,和下一个要执行的语句地址传递给被调函数保存
			2.为被调函数定义的变量和形参分配空间
			3. cpu的控制转移到被调函数的入口
			
		从被调函数返回到主函数之前,也会做三件事
			1.保存被调函数的返回结果 
			2.释放被调函数所占用的空间(静态空间) 
			3.依照被调函数保存的返回地址(下一个要执行的语句地址)将控制转移到调用函数
		因此A函数调用自己和A函数调用B在计算机看来是一模一样的 
		!当有多个函数互相调用时按照"后调用先返回的原则"相互之间信息传递和控制转移借助"栈"来实现
		系统将一个程序所需的空间安排在一个栈中
		每调用一个函数时就在栈顶分配空间,进行压栈
		退出函数时就出栈 
	
	递归必须满足的三个条件:
		1.递归必须有明确的终止条件
		2.函数处理的数据规模必须是递减的(值可以增加) 
			eg:可以是if(n<3) 	然后每一次递归n-- 
				也可以是if(n>3)	然后每一次递归n++ 
		3.这个转化必须是可解的(数学问题)
		
	循环和递归的关系 
		理论上所有的循环都可以用递归解决
		但递归不一定能用循环来解决
		
	循环和递归的优缺点
		递归的优点:易于理解
				缺点:速度慢,存储空间大
		循环:难理解,但速度快 
		
	递归的应用
		树和森林是以递归的方式定义的
		树和图中的算法是由递归定义的 
		
树
	定义:有且只有一个称为更的节点,有若干个互不相交的子树 
	通俗版:由节点和指针组成,每一个节点只有一个父节点,但可以有多个子节点,根节点例外
	专业术语:
		节点、父子节点、子孙、堂兄弟 
		深度：从根节点到最底层节点的层数
	叶子节点：
		没有子节点的节点
	非终端节点=非叶子节点
	度：子节点的个数（整个树的度就是树中最大最大子节点个数）  
	分类
		一般的树：任意一个节点的子节点数目不受限制 
		二叉树：任意一个节点的子节点的个数最多两个，且子节点个数不可更改，且为有序树 
				一般二叉树
				满二叉树(过度):在不增加层数的前提下，无法再添加任何一个元素  
				完全二叉树!:如果只是删除了满二叉树底层最右边的连续若干个节点,这样形成的二叉树就是完全二叉树 
		
		在用数组进行二叉树的数组(顺序)存储的时候内部必须是完全二叉树
		因此,一般树在存储时要转换成完全二叉树进行存储
		but why?
		因为如果只存放有效节点,我根据数组中元素的顺序无法回推出树原本的模样 
	  
		二叉树的存储
			连续存储[完全二叉树]
				优点:
					查找某个节点的父节点和子节点很方便 
				缺点: 
					占内存太大
			链式存储
				因为没有无效数据,因此不浪费内存 
				指针域(两个)
				数据域
		一般树的存储 
			双亲表示法:用结构体数组,其中结构体中有一整型变量存放父亲的下标 
			孩子表示法:指针域指向自己的所有孩子! 
			!!双亲孩子表示法:表头数组+父亲下标+孩子单链表(是上述两种的合体) 
			
			二叉树表示法(孩子兄弟法):把普通树转化成二叉树
						具体转化方法:
							设法保证任意一个节点的
								左指针指向第一个孩子
								右指针指向兄弟节点
								
			一个普通树转化成二叉树,根节点一定没有右子树 
 			一个森林转化成二叉树 ,根节点一定有右子树 
	 	森林的存储:用二叉树表示法差别在于根节点之间当成兄弟,其它都一样
		 
	操作
		树的遍历
			先序[先访问根节点](递归关系) 
				先访问根节点
				再先序访问左子树:如何先序遍历左子树?先访问它的根节点,再先序左子树... 
				再先序访问右子树 
			中序[中间访问根节点] 
当遇到根的时候不先访问它,而是先左再根再右子树 
				~左
				根 
				~右 
			后序[最后访问根节点] 
				~左
				~右
				根 
		已知两种遍历求原始的树
			除了已知先后不行之外,另外两种都可以推出原始二叉树
	应用:
		数据库中数据组织的一种形式
		操作系统子父进程关系
		面向对象语言中类的继承关系
		赫夫曼树
	
	排序:
		冒泡
			1、2比2、3比... 
		插入
			一个一个往前插入，使前面的有序 
		选择
			1和后面全部比，2和后面全部比... 
		快速
			
		归并
			
	排序和查找的关系:
		排序是查找的前提
		排序是重点 
		
再次讨论数据结构的含义：
	从某个角度而言，数据存储的核心在于数据之间关系的存储！而不是个体是个啥型
	
再次讨论什么是范型
	同一种逻辑结构，无论逻辑结构物理存储是什么
	都可以对它执行相同的操作 
